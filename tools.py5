# utils/tools.py
import os
import json
import re
from typing import Dict, Any, Optional, Tuple, List, Callable

import requests

from .call_llm import call_llm

import logging
from logging.handlers import RotatingFileHandler

_logger = logging.getLogger("qin_chatbot_llm")
if not _logger.handlers:
    _logger.setLevel(logging.INFO)

    # 控制台
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)

    # 文件（自动轮转，避免无限增长）
    fh = RotatingFileHandler(
        filename=os.getenv("LLM_PROMPT_LOG", "llm_prompts.log"),
        maxBytes=5 * 1024 * 1024,
        backupCount=5,
        encoding="utf-8",
    )
    fh.setLevel(logging.INFO)

    fmt = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    ch.setFormatter(fmt)
    fh.setFormatter(fmt)

    _logger.addHandler(ch)
    _logger.addHandler(fh)
    _logger.propagate = False



CalcFn = Callable[[Dict[str, Any]], Dict[str, Any]]

def get_calc_fn_by_product() -> Dict[str, CalcFn]:
    return {
        "hardcover_book": call_qin_hardcover_calc_api,
        "paperback_book": call_qin_softcover_calc_api,
    }
# ------------------ JSON helper ------------------

def _extract_json_object(text: str) -> Optional[dict]:
    if not text:
        return None
    match = re.search(r"\{.*\}", text, re.S)
    if not match:
        return None
    try:
        return json.loads(match.group(0))
    except Exception:
        return None


# ------------------ Intent + params ------------------

def detect_intent_and_quote_params(question: str, history: str = "", quote_ctx: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    意图识别 + 参数抽取（带历史上下文）
    - intent: info | quote
    - product_type: 允许多种，但 server 侧会默认 hardcover
    - quantity/size/pages 抽取
    """

    quote_ctx = quote_ctx or {}

    prompt = f"""
You are an intent classification + parameter extraction assistant for a printing website chatbot.

CONVERSATION HISTORY (may be empty):
{history}

CURRENT STORED QUOTE CONTEXT (may be empty):
{json.dumps(quote_ctx, ensure_ascii=False)}

Now classify the user's latest message and extract parameters.

1) intent:
- "info": general explanations/how-to/requirements without clear purchase intent
- "quote": user wants to print/order OR shows purchase intent (even without "how much")

CRITICAL INTENT RULES:
- "quote": 
   a) User wants to print/order/get price.
   b) User provides NEW params (e.g. "change to 500 copies", "add 4 pages", "size 8.5x11").
   c) User confirms the quote (e.g. "ok", "yes", "go ahead") IF there are pending fields.
   
- "info": 
   a) User asks general questions (e.g. "What finishes are available?", "What implies 4C/4C?", "How long is shipping?").
   b) User asks for EXPLANATIONS, even if a quote is active.
   c) If the user asks "What options do you have?" -> Intent is INFO (Knowledge Base), NOT quote parameter filling.
   
IMPORTANT:
- If the user is in the middle of a quote conversation (quote_ctx.active=true or quote_ctx has pending fields),
  and the user replies with something short like "yes/ok/sure" or provides size/pages/quantity,
  treat it as "quote" continuation.

2) product_type (best effort, if quote):
Allowed values:
hardcover_book,paperback_book,folder_book,selfcoverboard_book,hardcoverboard_book,poster_book,flyer_book,saddle_book,wireo_book,calendar_book,calendardesk_book,unknown

3) Extract (if present):
- quantity: int
- size_unit: "inch" or "mm"
- width, height: floats if like "8.5 x 11" or "210 x 297"
- page_count: int if like "64 pages"

4) Return missing_fields ONLY if intent="quote".
Allowed missing_fields:
- quantity, size_unit, width, height, page_count

5) If intent="info", missing_fields must be [].

6) If user asks pricing for multiple quantities like “50 / 100 / 200”, fill quantities with [50,100,200].
In that case, quantity can be null.

7) Shipping request extraction:
- need_shipping: true if user asks shipping / delivery / ship to / delivered to / DDP / CIF etc.
- shipping_country: country name if mentioned ("USA"/"US" => "United States"; "AU" => "Australia")
- shipping_postcode: postal/zip if mentioned (do NOT guess)
- shipping_region: state/province if mentioned (e.g. CA, NSW)
- shipping_city: city if mentioned

If need_shipping=true, include missing_shipping_fields with allowed values:
- shipping_country, shipping_postcode

If need_shipping=false, missing_shipping_fields must be [].

User message:
\"\"\"{question}\"\"\"

Return ONLY ONE JSON object using schema:

{{
  "intent": "info" | "quote",
  "product_type": "hardcover_book" | "paperback_book" | "comic_book" | "board_book" | "card_deck" | "packaging_box" | "other_printing" | "unknown" | null,
  "quantity": int | null,
  "quantities": [int, ...] | null,
  "width": float | null,
  "height": float | null,
  "size_unit": "inch" | "mm" | null,
  "page_count": int | null,
  "missing_fields": [string, ...],

  "need_shipping": true | false,
  "shipping_country": string | null,
  "shipping_postcode": string | null,
  "shipping_region": string | null,
  "shipping_city": string | null,
  "missing_shipping_fields": [string, ...]
  
}}
""".strip()

    raw = call_llm(prompt)
    data = _extract_json_object(raw)

    result = {
        "intent": "info",
        "product_type": None,
        "quantity": None,
        "quantities": None,
        "width": None,
        "height": None,
        "size_unit": None,
        "page_count": None,
        "missing_fields": [],
        
        "need_shipping": False,
        "shipping_country": None,
        "shipping_postcode": None,
        "shipping_region": None,
        "shipping_city": None,
        "missing_shipping_fields": [],
    }

    if not data or not isinstance(data, dict):
        return result

    for k in result.keys():
        if k in data:
            result[k] = data.get(k)

    # sanitize intent
    if result["intent"] not in ("info", "quote"):
        result["intent"] = "info"

    # sanitize product_type
    allowed_pt = {
        None,
        "hardcover_book", "paperback_book", "comic_book", "board_book",
        "card_deck", "packaging_box", "other_printing", "unknown",
    }
    if result["product_type"] not in allowed_pt:
        result["product_type"] = "unknown" if result["intent"] == "quote" else None

    # normalize numeric fields
    if isinstance(result.get("quantity"), str) and result["quantity"].isdigit():
        result["quantity"] = int(result["quantity"])
    if isinstance(result.get("page_count"), str) and result["page_count"].isdigit():
        result["page_count"] = int(result["page_count"])

    for dim in ("width", "height"):
        v = result.get(dim)
        try:
            if isinstance(v, str):
                result[dim] = float(v)
        except Exception:
            result[dim] = None
            
    qs = data.get("quantities")
    if isinstance(qs, list):
        q2 = []
        for x in qs:
            try:
                xi = int(str(x).strip())
                if xi > 0:
                    q2.append(xi)
            except:
                pass
        result["quantities"] = sorted(list(dict.fromkeys(q2)))[:5] or None
                
        # sanitize need_shipping
        result["need_shipping"] = bool(result.get("need_shipping"))
        
        # rebuild missing_shipping_fields
        if result["need_shipping"]:
        
            # normalize shipping fields
            for k in ("shipping_country", "shipping_postcode", "shipping_region", "shipping_city"):
                v = result.get(k)
                result[k] = str(v).strip() if isinstance(v, str) and str(v).strip() else None
                
            miss_shipping = []
            if not result.get("shipping_country"):
                miss_shipping.append("shipping_country")
            if not result.get("shipping_postcode"):
                miss_shipping.append("shipping_postcode")
            result["missing_shipping_fields"] = miss_shipping
        else:
            result["missing_shipping_fields"] = []

    # rebuild missing_fields for quote (server 侧会自己再算一次，这里做个一致性兜底)
    if result["intent"] == "quote":
        missing = set()
        if not isinstance(result.get("quantity"), int) or result["quantity"] <= 0:
            missing.add("quantity")
        if result.get("size_unit") not in ("inch", "mm"):
            missing.add("size_unit")
        if result.get("width") is None:
            missing.add("width")
        if result.get("height") is None:
            missing.add("height")
        if not isinstance(result.get("page_count"), int) or result["page_count"] <= 0:
            missing.add("page_count")

        if isinstance(data.get("missing_fields"), list):
            for f in data["missing_fields"]:
                f = str(f).strip()
                if f in {"quantity", "size_unit", "width", "height", "page_count"}:
                    missing.add(f)

        result["missing_fields"] = sorted(missing)
    else:
        result["missing_fields"] = []

    return result


# ------------------ Calc API ------------------
HARDCOVER_LAMINATION_MAP = {
    "matte": "127##Matte lamination",
    "gloss": "128##Gloss lamination",
    "soft_touch": "305##Soft touch lamination",
}

_LAM_SOFT_PAT = re.compile(r"\b(soft\s*touch|soft[-\s]?touch|velvet)\b", re.I)
_LAM_GLOSS_PAT = re.compile(r"\b(gloss|glossy|shine|shiny)\b", re.I)
_LAM_MATTE_PAT = re.compile(r"\b(matte|mat|dull|non[-\s]?gloss)\b", re.I)

def detect_lamination_value(params: Dict[str, Any]) -> Optional[str]:
    """
    从 params 里识别 lamination，返回形如 "127##Matte lamination" 的值。
    约定：你可以把用户原话或已抽取的 finish 字段放在以下任一键里：
      - params["lamination"]
      - params["finish"]
      - params["finishes"]
      - params["user_text"]  (如果你愿意传入原始文本)
    """
    # 取可能的输入源
    raw = (
        params.get("lamination")
        or params.get("finish")
        or params.get("finishes")
        or params.get("user_text")
        or ""
    )
    if not raw:
        return None
    t = str(raw).strip().lower()
    if not t:
        return None

    # 优先 soft touch（避免 "soft touch matte" 之类混合时误判）
    if _LAM_SOFT_PAT.search(t):
        return HARDCOVER_LAMINATION_MAP["soft_touch"]
    if _LAM_GLOSS_PAT.search(t):
        return HARDCOVER_LAMINATION_MAP["gloss"]
    if _LAM_MATTE_PAT.search(t):
        return HARDCOVER_LAMINATION_MAP["matte"]

    return None

def fmt_num(x):
    # 8.0 -> "8", 8.3 -> "8.3"
    return f"{float(x):g}"
    
def call_qin_hardcover_calc_api(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    调用你现有的 hardcover 报价 API：
    https://calc-api.qinprinting.com/index/index/showprice.html

    params 需要至少包含:
    - quantity
    - width / height
    - size_unit ("inch" / "mm")
    - page_count

    这里先用你之前提供的“标准 hard cover 模板参数”作为 baseQuery，
    然后根据用户参数覆盖几个关键字段。
    """
    
    calc_url = "https://calc-api.qinprinting.com/index/index/showprice.html"

    base_query = (
        "bookcount=500&booksize=606%23%238.5%E2%80%9D+x+11%E2%80%9D%23%23216%2C280&"
        "hardcoverbooksizeinch=inch&custom-length=&custom-width=&"
        "bookzhuangding=280%23%23Sewing+and+hardcover+binding&"
        "bookbaozhuang=17%23%23Carton&"
        "Hardcover-wire-o-binding=Hardcover-wire-o-binding&"
        "Hardcover-sewing-and-hardcover-binding=Hardcover-sewing-and-hardcover-binding&"
        "bookpages=32&"
        "bookpaper2%5B%5D=35&bookpaper2%5B%5D=Gloss+art+paper&bookpaper2%5B%5D=157%2C8500%2C0.136&"
        "cover-mate=paper-cover&"
        "bookpaper1%5B%5D=35&bookpaper1%5B%5D=Gloss+art+paper&bookpaper1%5B%5D=157%2C8500%2C0.136&"
        "bookgongyi=127%23%23Matte+lamination&"
        "cloth-color=Black+(ZT-5519)&"
        "leather-color=1-cream+grey+(PH-16)&"
        "130-count=1&275-count=1&131-count=1&181-count=1&142-count=1&"
        "bookboard=2.5&cover-spine=Square+Back&bookblank=blank&"
        "bookpaper5%5B%5D=70&bookpaper5%5B%5D=Offset+paper&bookpaper5%5B%5D=140%2C9000%2C0.16&"
        "hf%5Bflapwidth%5D=3.5&hf%5Bbookpaper1%5D=35&hf%5Bbookpaper2%5D=200%2C8500%2C0.178&"
        "hf%5Bbookpaper1name%5D=Gloss+art+paper&hf%5Bbookgongyi%5D=127%23%23Matte+lamination&"
        "hf%5B131-count%5D=1&hf%5B130-count%5D=1&hf%5B275-count%5D=1&hf%5B142-count%5D=1&"
        "ribboncolor=693+Pale+Gold&"
        "slipcase-mate=paper-slipcase&"
        "slipcase-bookpaper1%5B%5D=35&slipcase-bookpaper1%5B%5D=Gloss+art+paper&"
        "slipcase-bookpaper1%5B%5D=157%2C8500%2C0.136&"
        "slipcase%5Bbookgongyi%5D=127%23%23Matte+lamination&"
        "slipcase-cloth-color=Black+(ZT-5519)&"
        "slipcaseboard=2.5&"
        "slipcase%5B131-count%5D=1&slipcase%5B130-count%5D=1&slipcase%5B275-count%5D=1&"
        "slipcase%5B181-count%5D=1&slipcase%5B142-count%5D=1&"
        "product=2&producttype=jingzhuang&windowWidth=1905&windowHeight=9104&qinsid=r9374orv1qvnuif4ss1j7v61f2"
    )

    base_params: Dict[str, Any] = {}
    from urllib.parse import parse_qs

    parsed = parse_qs(base_query, keep_blank_values=True)
    for k, v in parsed.items():
        base_params[k] = v[0] if len(v) == 1 else v

    qty = params.get("quantity")
    if isinstance(qty, int) and qty > 0:
        base_params["bookcount"] = str(qty)

    size_unit = params.get("size_unit") or "inch"
    if size_unit not in ("inch", "mm"):
        size_unit = "inch"
    base_params["hardcoverbooksizeinch"] = size_unit

    page_count = params.get("page_count") or 32
    base_params["bookpages"] = str(int(page_count))

    #  booksize, 自定义模式，拿到width ,height 拼为：-1##8.3X12inch##8.3,12
    width  = params.get("width")  or 8.5
    height = params.get("height") or 11
    w = fmt_num(width)
    h = fmt_num(height)
    
    base_params["booksize"] = f"-1##{w}X{h}{size_unit}##{w},{h}"
    base_params["custom-width"] = w
    base_params["custom-length"] = h

    lam_val = detect_lamination_value(params)
    if lam_val:
        # cover lamination
        base_params["bookgongyi"] = lam_val
        # hardcover related lamination (hf)
        #base_params["hf[bookgongyi]"] = lam_val
        # slipcase lamination (if slipcase exists in base params)
        #base_params["slipcase[bookgongyi]"] = lam_val

    try:
        resp = requests.post(
            calc_url,
            data=base_params,
            timeout=15,
            headers={"Content-Type": "application/x-www-form-urlencoded"},
        )
    except Exception as e:
        return {"error": f"calc api request error: {e}", "raw_type": "error"}

    if resp.status_code >= 400:
        return {"error": f"calc api http {resp.status_code}", "raw": resp.text, "raw_type": "http_error"}

    try:
        return {"raw_type": "json", "data": resp.json()}
    except Exception:
        return {"raw_type": "text", "data": resp.text}

from typing import Dict, Any, Optional
import requests
from urllib.parse import parse_qs

def call_qin_softcover_calc_api(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    调用你现有的 softcover / paperback 报价 API：
    https://calc-api.qinprinting.com/index/index/showprice.html

    params 需要至少包含:
    - quantity
    - width / height
    - size_unit ("inch" / "mm")
    - page_count

    逻辑：
    1) 先用 softcover 的 base_query 作为模板
    2) 覆盖：数量/尺寸单位/页数/自定义尺寸booksize/custom-width/custom-length
    3) 可选覆盖：封面覆膜 bookgongyi（matte/gloss/soft touch）
    """

    calc_url = "https://calc-api.qinprinting.com/index/index/showprice.html"

    # 你提供的 softcover 模板参数（puzhuang）
    base_query = (
        "bookcount=500&"
        "booksize=498%23%238.5%E2%80%9D+x+11%E2%80%9D%23%23216%2C280&"
        "hardcoverbooksizeinch=inch&"
        "custom-length=&custom-width=&"
        "bookzhuangding=139%23%23Sewing+and+perfect+binding&"
        "bookbaozhuang=17%23%23Carton&"
        "bookpages=32&"
        "bookpaper2%5B%5D=35&bookpaper2%5B%5D=Gloss+art+paper&bookpaper2%5B%5D=128%2C8500%2C0.105&"
        "bookpaper1%5B%5D=35&bookpaper1%5B%5D=Gloss+art+paper&bookpaper1%5B%5D=250%2C8500%2C0.225&"
        "bookgongyi=127%23%23Matte+lamination&"
        "131-count=1&130-count=1&275-count=1&142-count=1&"
        "product=39&producttype=puzhuang&"
        "windowWidth=1543&windowHeight=8385&"
        "qinsid=67j72ld0q82ssaacfm0p2jhdgj"
    )

    # parse base query
    base_params: Dict[str, Any] = {}
    parsed = parse_qs(base_query, keep_blank_values=True)
    for k, v in parsed.items():
        base_params[k] = v[0] if len(v) == 1 else v

    # 1) quantity
    qty = params.get("quantity")
    if isinstance(qty, int) and qty > 0:
        base_params["bookcount"] = str(qty)

    # 2) size_unit
    size_unit = params.get("size_unit") or "inch"
    if size_unit not in ("inch", "mm"):
        size_unit = "inch"
    # 注意：接口字段就是这个（沿用你模板）
    base_params["hardcoverbooksizeinch"] = size_unit

    # 3) page_count
    page_count = params.get("page_count") or 32
    try:
        base_params["bookpages"] = str(int(page_count))
    except Exception:
        base_params["bookpages"] = "32"

    # 4) custom size -> booksize / custom-width / custom-length
    width  = params.get("width")  or 8.5
    height = params.get("height") or 11
    w = fmt_num(width)
    h = fmt_num(height)

    # 与 hardcover 同样的自定义格式：-1##8.5X11inch##8.5,11
    base_params["booksize"] = f"-1##{w}X{h}{size_unit}##{w},{h}"
    base_params["custom-width"] = w
    base_params["custom-length"] = h

    # 5) lamination (matte / gloss / soft touch)
    # 约定：params 里可以放 lamination/finish/finishes/user_text
    lam_val = detect_lamination_value(params)
    if lam_val:
        base_params["bookgongyi"] = lam_val

    # request
    try:
        resp = requests.post(
            calc_url,
            data=base_params,
            timeout=15,
            headers={"Content-Type": "application/x-www-form-urlencoded"},
        )
    except Exception as e:
        return {"error": f"calc api request error: {e}", "raw_type": "error"}

    if resp.status_code >= 400:
        return {"error": f"calc api http {resp.status_code}", "raw": resp.text, "raw_type": "http_error"}

    try:
        return {"raw_type": "json", "data": resp.json()}
    except Exception:
        return {"raw_type": "text", "data": resp.text}

# ------------------ Quote formatting (Mixam-like) ------------------

def _find_money_candidates(obj: Any) -> List[Tuple[str, float]]:
    """
    在未知 JSON 结构里，尽量找可能的价格字段（total/unit 等）。
    返回 (path, value) 列表
    """
    out = []

    def walk(x: Any, path: str):
        if isinstance(x, dict):
            for k, v in x.items():
                walk(v, f"{path}.{k}" if path else k)
        elif isinstance(x, list):
            for i, v in enumerate(x):
                walk(v, f"{path}[{i}]")
        else:
            # number
            if isinstance(x, (int, float)):
                key = path.lower()
                if any(w in key for w in ["price", "total", "amount", "cost", "unit"]):
                    out.append((path, float(x)))
            # string like "$123.45" / "123.45"
            if isinstance(x, str):
                key = path.lower()
                if any(w in key for w in ["price", "total", "amount", "cost", "unit"]):
                    m = re.search(r"(\d+(\.\d+)?)", x.replace(",", ""))
                    if m:
                        try:
                            out.append((path, float(m.group(1))))
                        except Exception:
                            pass

    walk(obj, "")
    return out


def _extract_best_prices(quote_struct: Dict[str, Any], qty: Optional[int] = None) -> Dict[str, Any]:
    """
    优先使用 calc 已知字段（realprice / pdfSpec）取 total。
    unit 永远用 total/qty 计算，避免被 HTML 中的 class 数字(如 hd615) 误导。
    """
    data = quote_struct.get("data", quote_struct)

    total: Optional[float] = None
    unit: Optional[float] = None

    # 1) 强优先：realprice = "$1761"
    if isinstance(data, dict):
        rp = str(data.get("realprice", "") or "")
        m = re.search(r"(\d+(?:\.\d+)?)", rp.replace(",", ""))
        if m:
            total = float(m.group(1))

    # 2) 次优先：pdfSpec 里最后一个 "USD xxxx"（折扣后价通常在最后）
    if total is None and isinstance(data, dict):
        pdf = str(data.get("pdfSpec", "") or "")
        nums = re.findall(r"USD\s*([0-9]+(?:\.[0-9]+)?)", pdf.replace(",", ""))
        if nums:
            total = float(nums[-1])

    # 3) 再兜底：扫描候选（保留给 debug 用）
    cands = _find_money_candidates(data)
    if total is None and cands:
        total = max(v for _, v in cands)

    # 4) unit：只按 qty 算（不再从 cands 里猜）
    if total is not None and isinstance(qty, int) and qty > 0:
        unit = round(total / qty, 4)

    return {"total": total, "unit": unit, "candidates": cands[:10]}


def format_quote_for_user_bak(user_question: str, params: Dict[str, Any], quote_struct: Dict[str, Any]) -> str:
    if quote_struct.get("error"):
        return "I tried to calculate a quote, but there was an error from the pricing system: " + str(quote_struct["error"])

    # 先抽取（尽量不用 LLM 猜数字）
    price_info = _extract_best_prices(quote_struct, qty=params.get("quantity"))
    total = price_info.get("total")
    unit = price_info.get("unit")

    qty = params.get("quantity")
    w = params.get("width")
    h = params.get("height")
    u = params.get("size_unit")
    pages = params.get("page_count")

    # 把“已知数字”直接喂给 LLM，让它负责口语化/结构，不负责猜数字
    known = {
        "spec": {"quantity": qty, "width": w, "height": h, "unit": u, "page_count": pages},
        "prices": {"total": total, "unit": unit},
        "raw_type": quote_struct.get("raw_type"),
    }

    prompt = f"""
You are a printing sales assistant for QinPrinting.
Write a smooth quote reply in English.

User question:
\"\"\"{user_question}\"\"\"

Known quote context (DO NOT change numbers, DO NOT invent numbers):
{json.dumps(known, ensure_ascii=False)}

Rules:
- If prices.total exists, show it as the main price for the run.
- If prices.unit exists, show unit price too.
- If one of them is missing, say it's not available in this estimate (do NOT guess).
- Keep it concise and friendly.
- Mention this is an online estimate (EXW Shanghai) and shipping/duty not included.
- End with 2-5 quick options/questions to customize (quantity / size / pages / finishes / extras).
""".strip()

    answer = call_llm(prompt)
    return answer.strip() if answer else "Sorry, I could not interpret the quote result."
    
#------------------------------根据raw_quote--------------------------------------------------


def parse_pdf_spec(pdf_spec: str) -> Dict[str, str]:
    """
    把 pdfSpec (带 \\r\\n 的长字符串) 解析成 {key: value}
    """
    if not pdf_spec:
        return {}

    # 还原换行
    s = pdf_spec.replace("\\r\\n", "\n").replace("\r\n", "\n").replace("\r", "\n")
    lines = [ln.strip().strip(";") for ln in s.split("\n") if ln.strip()]

    out: Dict[str, str] = {}
    title = lines[0] if lines else ""
    if title and ":" not in title:
        out["Product"] = title

    for ln in lines:
        if ":" in ln:
            k, v = ln.split(":", 1)
            out[k.strip()] = v.strip().strip(";")
    return out


def spec_bullets_from_parsed(parsed: Dict[str, str]) -> Dict[str, Any]:
    bullets = []

    # Binding
    binding = parsed.get("Binding", "")
    if binding:
        # 你可以根据关键词做“更好听但不改事实”的转述
        #if "sewing" in binding.lower() and "hardcover" in binding.lower():
        #    bullets.append("Premium Smyth-sewn hardcover binding (sewn + case bound)")
        #else:
        bullets.append(f"Binding: {binding}")

    # Inner / pages / color
    inner = parsed.get("Inner", "")
    pages = None
    m = re.search(r"(\d+)\s*pages", inner, re.I)
    if m:
        pages = int(m.group(1))

    if inner:
        # 4C/4C -> full color both sides
        if re.search(r"\b4c\s*/\s*4c\b", inner, re.I):
            bullets.append(f"Full-color interior (4C/4C){f' — {pages} pages' if pages else ''}")
        elif re.search(r"\b4c\s*/\s*0c\b", inner, re.I):
            bullets.append(f"Interior printing: 4C/0C{f' — {pages} pages' if pages else ''}")
        else:
            bullets.append(f"Interior: {inner}")

    # Cover lamination
    cover = parsed.get("Paper cover", "")
    if cover:
        if "matte lamination" in cover.lower():
            bullets.append("Matte laminated hard cover (outside)")
        elif "gloss lamination" in cover.lower():
            bullets.append("Gloss laminated hard cover (outside)")
        else:
            bullets.append(f"Hard cover: {cover}")

    # End sheets
    ends = parsed.get("End sheets", "")
    if ends:
        bullets.append("End papers included")

    # Dust jacket（只有在 pdfSpec 里真的出现时才列）
    dj = None
    for k in parsed.keys():
        if "dust" in k.lower() or "jacket" in k.lower():
            dj = parsed.get(k)
            break
    if dj:
        bullets.append(f"Dust jacket: {dj}")

    return {"bullets": bullets, "raw": parsed}

def format_quote_for_user(user_question: str, params: Dict[str, Any], quote_struct: Dict[str, Any]) -> str:
    if quote_struct.get("error"):
        return "I tried to calculate a quote, but there was an error from the pricing system: " + str(quote_struct["error"])

    data = quote_struct.get("data", quote_struct)
    pdf_spec = ""
    if isinstance(data, dict):
        pdf_spec = data.get("pdfSpec", "") or ""

    parsed = parse_pdf_spec(pdf_spec)
    spec_pack = spec_bullets_from_parsed(parsed)

    price_info = _extract_best_prices(quote_struct, qty=params.get("quantity"))
    total = price_info.get("total")
    unit = price_info.get("unit")

    known = {
        "spec_input": {
            "quantity": params.get("quantity"),
            "width": params.get("width"),
            "height": params.get("height"),
            "unit": params.get("size_unit"),
            "page_count": params.get("page_count"),
        },
        "prices": {"total": total, "unit": unit},
        "spec_from_calc": {
            "parsed_pdf_spec": parsed,          # 机器字段
            "spec_bullets": spec_pack["bullets"]# 给用户看的 bullets
        }
    }

    prompt = f"""
You are a printing sales assistant for QinPrinting.
Write a concise quote reply in English.

User question:
\"\"\"{user_question}\"\"\"

Known quote context (DO NOT change numbers, DO NOT invent specs not present):
{json.dumps(known, ensure_ascii=False)}

Rules:
- Show the key spec bullets under a short "This estimate includes:" section.
- Prices: if total exists, show it; if unit exists, show it; if missing, say not available (do NOT guess).
- Price Number and currency symbol should be in bold model;
- Mention: online estimate, EXW Shanghai, shipping/duty not included.
- Keep it concise and friendly.
- Mention this is an online estimate (EXW Shanghai) and shipping/duty not included.
- End with 2-5 quick options/questions to customize (quantity / size / pages / finishes / extras).
""".strip()

    answer = call_llm(prompt)
    return answer.strip() if answer else "Sorry, I could not interpret the quote result."

def format_batch_quote_for_user(user_question: str, base_params: Dict[str, Any], batch_prices: List[Dict[str, Any]], bullets: List[str]) -> str:
    """
    LLM 负责组织语言；数字/数量来自 batch_prices，不允许改。
    batch_prices: [{"qty":50,"total":1016,"unit":20.32}, ...]
    """
    spec_bullets = []
    if isinstance(bullets, dict):
        data_i = bullets.get("data", {})
        pdf_i = data_i.get("pdfSpec", "") if isinstance(data_i, dict) else ""
        parsed_i = parse_pdf_spec(pdf_i)
        spec_pack_i = spec_bullets_from_parsed(parsed_i)
        spec_bullets = spec_pack_i["bullets"]
        
    known = {
        "spec_input": base_params,
        "spec_bullets": spec_bullets,
        "batch_prices": batch_prices,
        "notes": {
            "pricing_terms": "Online estimate, EXW Shanghai. Shipping/duties not included.",
            "number_rule": "DO NOT change any numbers. Use batch_prices exactly."
        }
    }

    prompt = f"""
You are a printing sales assistant for QinPrinting.
Write a concise, friendly quote reply in English.

User question:
\"\"\"{user_question}\"\"\"

Known data (DO NOT change numbers; DO NOT invent missing specs):
{json.dumps(known, ensure_ascii=False)}

Rules:
- Start with 1 short intro line.
- Add a section "This estimate includes:" and list the provided spec_bullets.
- Add a section "Prices (EXW Shanghai):" with one line per quantity.
  Format each price line in bold model.
  Example:
  **50 copies: USD 1,234 total (USD 24.68 each)**
- Price Number and currency symbol should be in bold model;
- Keep it concise and friendly.
- Mention this is an online estimate (EXW Shanghai) and shipping/duty not included.
- End with 2-5 quick options/questions to customize (quantity / size / pages / finishes / extras).

Return only the final message text.
""".strip()

    _logger.info(
        "format_batch_quote_for_user PROMPT\nPROMPT=\n%s\n---END PROMPT---",
        prompt
    )
    
    ans = call_llm(prompt)
    return ans.strip() if ans else "Sorry, I could not format the batch quote."

def extract_prices_for_qty(quote_raw: Dict[str, Any], qty: int) -> Dict[str, Any]:
    return _extract_best_prices(quote_raw, qty=qty)

# ------------------ Lead submit ------------------

def send_lead_to_wpforms(name: str, email: str, from_url: str = "") -> None:
    endpoint = os.getenv("CHATBOT_LEAD_ENDPOINT")
    if not endpoint:
        return

    payload = {
        "name": name,
        "email": email,
        "source": "chatbot",
        "from_url": from_url,
    }

    try:
        requests.post(endpoint, json=payload, timeout=10)
    except Exception as e:
        print("send_lead_to_wpforms error:", e)
